## 요약 

### 어댑터 패턴 (Adapter)
> 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환한다
인터페이스가 호환되지 않아 사용할 수 없던 클래스를 사용할 수 있게 변환하는 패턴이다

**장점**
- 기존 코드(adpatee)를 변경하지 않고 원하는 인터페이스 구현체를 만들어 재사용할 수 있다 (OCP 원칙 준수)
- 기존 코드가 하던 일과 특정 인터페이스 구현체로 변환하는 작업을 각기 다른 클래스로 분리하여 관리할 수 있다 (SRP 원칙 준수)

**단점** <br/>
- 어댑터 클래스가 생겨 복잡도가 증가할 수 있다 <br/>
-> 경우에 따라 기존 코드가 해당 인터페이스를 구현하도록 수정하는 것이 좋은 선택일 수 있다

<img src="https://github.com/ljw1126/user-content/blob/master/head-first-design-pattern/adapter/adapter.png?raw=true"> 

① Client에서는 Target 인터페이스로 요청을 보낸다
<br/>
② Target 인터페이스를 구현한 Adapter 클래스로 전달된다
<br/>
③ Adapter 클래스는 자신이 감싸고 있는 (Wrapper) Adaptee에게 실질적인 요청을 위임한다
<br/>
④ 결국 Target.request() - Adapter.request() - Adaptee.specificRequest() 가 연결된다

---

## 어댑터와 데코레이터 패턴 비교 
**공통점**
- 모두 S/W 구조를 개선하기 위한 디자인 패턴
- 기존 클래스와 새로운 클래스 사이의 협력을 통해 기능을 확장

**목적의 차이**
- 데코레이터 패턴 : 객체의 행동을 동적으로 확장하고 변화시키는데 사용된다. 주로 객체의 행동을 런타임 시점에 변경시 유용함
- 어댑터 패턴 : 호환되지 않는 인터페이스를 갖는 클래스를 사용할 수 있는 인터페이스의 구현체로 바꿔주는데 사용
